# -*- coding = utf-8 -*-
# by XS-Jinbert
# only can download from https://asmhentai.com/

from bs4 import BeautifulSoup
import requests
import threading
import time
import os
import re

findPage = re.compile(r'<h3>Pages: (.*?)</h3>')
findArtists = re.compile(r'<div class="tag_list"><a href="/artists/name/(.*?)/"><span class="badge tag">')
findTitle = re.compile(r'<h2>(.*?)</h2>')
findSaveID = re.compile(r'images.asmhentai.com/(.*?)/')

def main():
    bookID = input("请输入本子编号：")
    book = bookDownload(bookID)
    book.RunThread()

class bookDownload:
    info = {
        "bookID": "00",
        "title": "",
        "artist": "",
        "page": {"Number": 0, "DownloadNumber": 1},
        "saveID": "001",
        "failPage": {},
        "bookURL": "https://asmhentai.com/g/",
        "pageURL": "https://images.asmhentai.com/",
        "root": "D://HentaiDownloader/"
    }
    lock = threading.RLock()

    def __init__(self, bookID):
        bookDownload.info["bookID"] = bookID

    # 发送请求获取网站html
    def askURL(self):
        url = bookDownload.info["bookURL"] + bookDownload.info["bookID"]
        html = ""
        try:
            r = requests.get(url, timeout=5)
            r.raise_for_status()
            html = r.text
        except Exception as e:
            print("请求本子网址出错：", str(e))

        return html

    # 获取必要信息
    def Findinfo(self, html):
        soup = BeautifulSoup(html, "html.parser")
        # 收集info的title、page["Nunber"]、artist信息
        right = soup.find_all("div", class_="right")
        right = str(right)

        title = re.findall(findTitle, right)  # 正则表达式收集日文/中文标题
        title[0] = title[0].replace("/", "")
        bookDownload.info["title"] = title[0]

        page = re.findall(findPage, right)  # 正则表达式收集本子页码
        bookDownload.info["page"]["Number"] = int(page[0])

        artist = re.findall(findArtists, right)  # 正则表达式收集本子作者
        print(artist)
        if(len(artist) > 0):
            bookDownload.info["artist"] = artist[0]
        else:
            bookDownload.info["artist"] = "ArtistUnknow"

        # 收集info的saveID
        ImageLink = soup.find_all("img", class_="lazy no_image")
        ImageLink = str(ImageLink)
        saveID = re.findall(findSaveID, ImageLink)
        bookDownload.info["saveID"] = saveID[0]

    # 获取图片内容
    def askImageURL(self, pagenumber):
        url = bookDownload.info["pageURL"] + bookDownload.info["saveID"] + "/" + bookDownload.info["bookID"] + "/" + pagenumber + ".jpg"
        try:
            r = requests.get(url, timeout=5)
            r.raise_for_status()
        except Exception as e:
            print("获取图片出错：", str(e))
        return r.content

    # 保存图片内容到当地
    def Download(self, content, n):
        root = bookDownload.info["root"] + bookDownload.info["artist"] + "/" + bookDownload.info["title"] + "//"
        path = root + n.zfill(4)+".jpg"
        try:
            if not os.path.exists("D://HentaiDownloader//"):                                    # 如果hentai下载根目录不存在则创建
                os.mkdir("D://HentaiDownloader//")
            if not os.path.exists("D://HentaiDownloader/"+bookDownload.info["artist"]+"//"):    # 如果本子作者根目录不存在则创建
                os.mkdir("D://HentaiDownloader/"+bookDownload.info["artist"]+"//")
            if not os.path.exists(root):                                                        # 如果本子根目录不存在则创建
                os.mkdir(root)

            if not os.path.exists(path):
                with open(path, "wb") as f:
                    f.write(content)
                    print("\033[1;36m第" + n + "页下载成功！\033[0m")
            else:
                print("\033[1;36m文件已存在\033[0m")
            pass
        except Exception as e:
            print("下载出错：", str(e))

    # 下载图片线程调用函数
    def DownloadThread(self, ThreadName):
        while True:
            print(ThreadName + " 开始运行")
            bookDownload.lock.acquire()
            print(ThreadName + " 上锁了")
            downloadPage = ""
            try:
                DownloadPage = bookDownload.info["page"]["DownloadNumber"]  # 访问将下载页数
                if DownloadPage > bookDownload.info["page"]["Number"] :
                    break
                downloadPage = str(DownloadPage)
                bookDownload.info["page"]["DownloadNumber"] = bookDownload.info["page"]["DownloadNumber"] + 1  # 将下载页数+1
            finally:
                bookDownload.lock.release()
                print(ThreadName + " 解锁了")
            print(ThreadName + " 开始下载第" + downloadPage + "页")
            content = bookDownload.askImageURL(self, downloadPage)
            bookDownload.Download(self, content=content, n=downloadPage)

    # 下载本子调用函数
    def RunThread(self):
        print("解析ing")
        html = bookDownload.askURL(self)
        bookDownload.Findinfo(self, html)
        print("解析成功")
        print("本子编号为：" + bookDownload.info["bookID"] + "\n标题为：" + bookDownload.info["title"] +
              "\n作者为：" + bookDownload.info["artist"] + "\n共" + str(bookDownload.info["page"]["Number"]) + "页")

        t1 = threading.Thread(target=bookDownload.DownloadThread(self, "本子"+bookDownload.info["bookID"]+"图片下载线程1"))
        t2 = threading.Thread(target=bookDownload.DownloadThread(self, "本子"+bookDownload.info["bookID"]+"图片下载线程2"))
        t3 = threading.Thread(target=bookDownload.DownloadThread(self, "本子"+bookDownload.info["bookID"]+"图片下载线程3"))

        t1.start()
        print("t1")
        t2.start()
        print("t2")
        t3.start()
        print("t3")

        # t1.join()
        # t2.join()
        # t3.join()

class Download_thread(threading.Thread):
    def __init__(self, thread_id):
        threading.Thread.__init__(self) # 需要对父类的构造函数进行初始化
        self.thread_id = thread_id

    def run(self):
        print('启动线程：', self.thread_id)
        self.DownloadThread()
        print('退出了该线程：', self.thread_id)

    def DownloadThread(self):
        while True:
            pass


if (__name__ == "__main__"):
    main()
